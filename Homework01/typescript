Script started on 2019-09-13 12:45:55-0400
]0;jmb237@gold27: ~/cs374/Homework01[01;32mjmb237@gold27[00m:[01;34m~/cs374/Homework01[00m$ ls
[0m[01;32mcircuitSatisfiability[0m    script_circuitSatisfiability_1_1.slurm    script_circuitSatisfiability_16_8.slurm  script_circuitSatisfiability_8_8.slurm
circuitSatisfiability.c  script_circuitSatisfiability_1_2.slurm    script_circuitSatisfiability_1_8.slurm   typescript
[01;32mcircuitSatisfiablilty[0m    script_circuitSatisfiability_1_4.slurm    script_circuitSatisfiability_2_8.slurm
jmb237@borg              script_circuitSatisfiability_16_16.slurm  script_circuitSatisfiability_4_8.slurm
]0;jmb237@gold27: ~/cs374/Homework01[01;32mjmb237@gold27[00m:[01;34m~/cs374/Homework01[00m$ cat circuitSatisfiability.c
/* circuitSatifiability.c solves the Circuit Satisfiability
 *  Problem using a brute-force sequential solution.
 *
 *   The particular circuit being tested is "wired" into the
 *   logic of function 'checkCircuit'. All combinations of
 *   inputs that satisfy the circuit are printed.
 *
 *   16-bit version by Michael J. Quinn, Sept 2002.
 *   Extended to 32 bits by Joel C. Adams, Sept 2013.
 */

#include <stdio.h>     // printf()
#include <limits.h>    // UINT_MAX
#include <mpi.h>

int checkCircuit (int, long);

int totalCount;

int main (int argc, char *argv[]) {
   long i;               // loop variable (64 bits) 
   int id = 0;           // process id 
   int count = 0;        // number of solutions
   int numProcesses = 12;
   totalCount = 0;

   double startTime = 0.0, totalTime = 0.0;

   // initialize MPI
   MPI_Init(&argc, &argv);
   MPI_Comm_rank(MPI_COMM_WORLD, &id);
   MPI_Comm_size(MPI_COMM_WORLD, &numProcesses);

   // start timer
   startTime = MPI_Wtime();

   // announce that each process has begun
   printf ("\nProcess %d is checking the circuit...\n", id);

   // split up the loop for the multiple processes
   for (i = id; i <= UINT_MAX; i+= numProcesses) {
      // add result to count variable
      count += checkCircuit (id, i);
   }

   // calculate total time the processing took
   totalTime = MPI_Wtime() - startTime;
   // print out how long it took
   printf ("Process %d finished in time %f secs.\n", id, totalTime);
   fflush (stdout);
   // combine all of the processes to the totalCount
   MPI_Reduce(&count, &totalCount, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);
   // finalize MPI
   MPI_Finalize();
   if (id == 0) {
      printf("\nA total of %d solutions were found.\n\n", totalCount);
   }
   return 0;
}

/* EXTRACT_BIT is a macro that extracts the ith bit of number n.
 *
 * parameters: n, a number;
 *             i, the position of the bit we want to know.
 *
 * return: 1 if 'i'th bit of 'n' is 1; 0 otherwise 
 */

#define EXTRACT_BIT(n,i) ( (n & (1<<i) ) ? 1 : 0)


/* checkCircuit() checks the circuit for a given input.
 * parameters: id, the id of the process checking;
 *             bits, the (long) rep. of the input being checked.
 *
 * output: the binary rep. of bits if the circuit outputs 1
 * return: 1 if the circuit outputs 1; 0 otherwise.
 */

#define SIZE 32

int checkCircuit (int id, long bits) {
   int v[SIZE];        /* Each element is one of the 32 bits */
   int i;

   for (i = 0; i < SIZE; i++) {
     v[i] = EXTRACT_BIT(bits,i);
   }

   if ( ( (v[0] || v[1]) && (!v[1] || !v[3]) && (v[2] || v[3])
       && (!v[3] || !v[4]) && (v[4] || !v[5])
       && (v[5] || !v[6]) && (v[5] || v[6])
       && (v[6] || !v[15]) && (v[7] || !v[8])
       && (!v[7] || !v[13]) && (v[8] || v[9])
       && (v[8] || !v[9]) && (!v[9] || !v[10])
       && (v[9] || v[11]) && (v[10] || v[11])
       && (v[12] || v[13]) && (v[13] || !v[14])
       && (v[14] || v[15]) )
       &&
          ( (v[16] || v[17]) && (!v[17] || !v[19]) && (v[18] || v[19])
       && (!v[19] || !v[20]) && (v[20] || !v[21])
       && (v[21] || !v[22]) && (v[21] || v[22])
       && (v[22] || !v[31]) && (v[23] || !v[24])
       && (!v[23] || !v[29]) && (v[24] || v[25])
       && (v[24] || !v[25]) && (!v[25] || !v[26])
       && (v[25] || v[27]) && (v[26] || v[27])
       && (v[28] || v[29]) && (v[29] || !v[30])
       && (v[30] || v[31]) ) )
   {
      printf ("%d) %d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d \n", id,
         v[31],v[30],v[29],v[28],v[27],v[26],v[25],v[24],v[23],v[22],
         v[21],v[20],v[19],v[18],v[17],v[16],v[15],v[14],v[13],v[12],
         v[11],v[10],v[9],v[8],v[7],v[6],v[5],v[4],v[3],v[2],v[1],v[0]);
      fflush (stdout);
      return 1;
   } else {
      return 0;
   }
}

]0;jmb237@gold27: ~/cs374/Homework01[01;32mjmb237@gold27[00m:[01;34m~/cs374/Homework01[00m$ mpicc circuitSatisfiability,.[K[K.c -Wall -ansi -pedantic -std=c99 -o circuitSatisfiability
]0;jmb237@gold27: ~/cs374/Homework01[01;32mjmb237@gold27[00m:[01;34m~/cs374/Homework01[00m$ exit

Script done on 2019-09-13 12:47:16-0400
